# -*- coding: utf-8 -*-
"""image-quantization-kmeans.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lROeA01Rm9jwZymTN2Ls4Rmd2Wvptysb
"""

import numpy as np
import matplotlib.pyplot as plt
from google.colab import files
from sklearn.cluster import KMeans
import os
from tempfile import NamedTemporaryFile

# Upload an image to the Colab environment
uploaded = files.upload()
image = plt.imread(list(uploaded.keys())[0])[:, :, :3] / 255.0  # Read the image and normalize RGB values to [0,1]

# Mode 1: Manual indexing without compression or clustering
def manual_index_image(image):
    pixels = image.reshape(-1, 3)  # Flatten image into 2D array of RGB vectors
    palette, indices = np.unique(pixels, axis=0, return_inverse=True)  # Extract unique colors and index each pixel
    index_image = indices.reshape(image.shape[:2])  # Reshape indices back to image shape
    return index_image, palette  # Return indexed image and palette

# Mode 2: Compression using KMeans in RGB space
def kmeans_index_image(image, n_clusters=128):
    pixels = image.reshape(-1, 3)  # Flatten image into 2D color array
    kmeans = KMeans(n_clusters=n_clusters, random_state=0, n_init=10)  # Define KMeans model
    labels = kmeans.fit_predict(pixels)  # Run KMeans and get labels
    palette = kmeans.cluster_centers_  # Cluster centers as color palette
    index_image = labels.reshape(image.shape[:2])  # Build indexed image
    return index_image, palette

# Convert from RGB to HSV
def rgb_to_hsv(image):
    image = np.array(image)
    shape = image.shape
    flat = image.reshape(-1, 3)  # Flatten image
    r, g, b = flat[:, 0], flat[:, 1], flat[:, 2]  # Extract R, G, B channels

    maxc = np.max(flat, axis=1)  # Max of R,G,B
    minc = np.min(flat, axis=1)  # Min of R,G,B
    diff = maxc - minc

    h = np.zeros_like(maxc)
    s = np.zeros_like(maxc)
    v = maxc  # V in HSV

    s[maxc != 0] = diff[maxc != 0] / maxc[maxc != 0]  # Compute S

    # Compute H depending on max channel
    mask = diff != 0
    idx = (maxc == r) & mask
    h[idx] = ((g[idx] - b[idx]) / diff[idx]) % 6
    idx = (maxc == g) & mask
    h[idx] = ((b[idx] - r[idx]) / diff[idx]) + 2
    idx = (maxc == b) & mask
    h[idx] = ((r[idx] - g[idx]) / diff[idx]) + 4

    h = (h * 60) % 360
    h /= 360  # Normalize H to [0,1]

    hsv = np.stack([h, s, v], axis=1)  # Combine HSV channels
    return hsv.reshape(*shape)

# Convert from HSV back to RGB (for reconstruction)
def hsv_to_rgb(hsv):
    hsv = np.array(hsv)
    shape = hsv.shape
    flat = hsv.reshape(-1, 3)

    h, s, v = flat[:, 0] * 360, flat[:, 1], flat[:, 2]
    c = v * s
    x = c * (1 - np.abs((h / 60) % 2 - 1))
    m = v - c

    rgb = np.zeros((len(flat), 3))

    # Assign RGB values based on hue sector
    cond0 = (0 <= h) & (h < 60)
    cond1 = (60 <= h) & (h < 120)
    cond2 = (120 <= h) & (h < 180)
    cond3 = (180 <= h) & (h < 240)
    cond4 = (240 <= h) & (h < 300)
    cond5 = (300 <= h) & (h < 360)

    rgb[cond0] = np.stack([c[cond0], x[cond0], np.zeros_like(c[cond0])], axis=-1)
    rgb[cond1] = np.stack([x[cond1], c[cond1], np.zeros_like(c[cond1])], axis=-1)
    rgb[cond2] = np.stack([np.zeros_like(c[cond2]), c[cond2], x[cond2]], axis=-1)
    rgb[cond3] = np.stack([np.zeros_like(c[cond3]), x[cond3], c[cond3]], axis=-1)
    rgb[cond4] = np.stack([x[cond4], np.zeros_like(c[cond4]), c[cond4]], axis=-1)
    rgb[cond5] = np.stack([c[cond5], np.zeros_like(c[cond5]), x[cond5]], axis=-1)

    rgb += m[:, np.newaxis]
    rgb = np.clip(rgb, 0, 1)
    return rgb.reshape(*shape)

# Mode 3: Color compression using KMeans in HSV space
def hsv_kmeans_index_image(image, n_clusters=128):
    hsv_image = rgb_to_hsv(image)  # Convert to HSV
    hsv_image = np.nan_to_num(hsv_image)  # Handle NaN if any
    pixels = hsv_image.reshape(-1, 3)  # Flatten
    kmeans = KMeans(n_clusters=n_clusters, random_state=0, n_init=10)
    labels = kmeans.fit_predict(pixels)  # Cluster in HSV space
    hsv_centers = kmeans.cluster_centers_
    rgb_palette = hsv_to_rgb(hsv_centers)  # Convert HSV palette to RGB
    index_image = labels.reshape(image.shape[:2])
    return index_image, rgb_palette

# Reconstruct image from indices and palette
def reconstruct_image(index_image, palette):
    return palette[index_image.astype(np.int32)]

# Show original, indexed and reconstructed images side by side
def plot_results(original, index_image, palette, title):
    reconstructed = reconstruct_image(index_image, palette)
    plt.figure(figsize=(15,5))

    plt.subplot(1,3,1)
    plt.imshow(original)
    plt.title('Original Image')

    plt.subplot(1,3,2)
    plt.imshow(index_image, cmap='nipy_spectral')
    plt.title(f'Index Map - {title}')

    plt.subplot(1,3,3)
    plt.imshow(reconstructed)
    plt.title(f'Reconstructed Image - {title}')

    plt.show()

# Calculate PNG file size for comparison
def calculate_size(index_image, palette, title):
    reconstructed = reconstruct_image(index_image, palette)
    with NamedTemporaryFile(suffix='.png', delete=False) as f:
        plt.imsave(f.name, reconstructed)
        size_kb = os.path.getsize(f.name) / 1024
    print(f'PNG file size for {title}: {size_kb:.2f} KB')

# Run Mode 1 (Manual)
index1, palette1 = manual_index_image(image)
plot_results(image, index1, palette1, 'Mode 1 (Manual)')
calculate_size(index1, palette1, 'Mode 1 (Manual)')

# Run Mode 2 (KMeans RGB)
index2, palette2 = kmeans_index_image(image, n_clusters=128)
plot_results(image, index2, palette2, 'Mode 2 (KMeans RGB)')
calculate_size(index2, palette2, 'Mode 2 (KMeans RGB)')

# Run Mode 3 (KMeans HSV)
index3, palette3 = hsv_kmeans_index_image(image, n_clusters=128)
plot_results(image, index3, palette3, 'Mode 3 (KMeans HSV)')
calculate_size(index3, palette3, 'Mode 3 (KMeans HSV)')